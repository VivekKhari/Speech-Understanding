# -*- coding: utf-8 -*-
"""Speech Understanding Task A.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dV8gVfUjyVv0s9W3jDnYIof0591IQ5mD
"""

import numpy as np
import librosa
import librosa.display
import matplotlib.pyplot as plt
import os
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score

from google.colab import drive
drive.mount('/content/drive')

# Set dataset path
dataset_path = "/content/drive/My Drive/UrbanSound8K"
metadata_file = os.path.join(dataset_path, "metadata/UrbanSound8K.csv")
audio_folder = os.path.join(dataset_path, "audio")

# Load metadata
metadata = pd.read_csv(metadata_file)

# Function to extract MFCC features and generate spectrograms
def extract_features(file_path, window_type='hann', n_mfcc=13):
    y, sr = librosa.load(file_path, sr=None)

    # Choose window function
    if window_type == 'hann':
        window = np.hanning(2048)
    elif window_type == 'hamming':
        window = np.hamming(2048)
    elif window_type == 'rectangular':
        window = np.ones(2048)
    else:
        raise ValueError("Invalid window type")

    # Compute STFT (spectrogram)
    stft_result = librosa.stft(y, n_fft=2048, hop_length=512, window=window)
    spectrogram = np.abs(stft_result)

    # Convert to dB scale
    spectrogram_db = librosa.power_to_db(spectrogram)

    # Compute MFCCs
    mfccs = librosa.feature.mfcc(S=spectrogram_db, sr=sr, n_mfcc=n_mfcc)

    return np.mean(mfccs, axis=1), spectrogram_db  # Return MFCCs and spectrogram

# Select a random file for visualization
sample_index = 100  # Change for a different sample
sample_row = metadata.iloc[sample_index]
sample_file = os.path.join(audio_folder, f"fold{sample_row['fold']}/{sample_row['slice_file_name']}")

# Apply all 3 windowing techniques and plot spectrograms
window_types = ['hann', 'hamming', 'rectangular']
fig, axs = plt.subplots(1, 3, figsize=(15, 5))

for i, window in enumerate(window_types):
    mfcc_features, spectrogram = extract_features(sample_file, window_type=window)

    # Plot spectrogram
    librosa.display.specshow(spectrogram, sr=22050, hop_length=512, x_axis='time', y_axis='log', ax=axs[i])
    axs[i].set_title(f"{window.capitalize()} Window")

plt.tight_layout()
plt.show()

# Extract features for SVM classification
features = {w: [] for w in window_types}
labels = []

for index, row in metadata.iterrows():
    file_name = os.path.join(audio_folder, f"fold{row['fold']}/{row['slice_file_name']}")
    label = row['classID']

    try:
        for window in window_types:
            mfcc_features, _ = extract_features(file_name, window_type=window)
            features[window].append(mfcc_features)
        labels.append(label)
    except Exception as e:
        print(f"Error processing {file_name}: {e}")

# Convert to NumPy arrays and save features
for window in window_types:
    features[window] = np.array(features[window])
    np.save(f"mfcc_features_{window}.npy", features[window])

labels = np.array(labels)
np.save("labels.npy", labels)

# Train and evaluate SVM for each window type
for window in window_types:
    print(f"\nTraining SVM with {window.capitalize()} Window Features...")

    X_train, X_test, y_train, y_test = train_test_split(features[window], labels, test_size=0.2, random_state=7)

    svm_model = SVC(kernel='rbf', C=10, gamma='scale')
    svm_model.fit(X_train, y_train)

    y_pred = svm_model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)

    print(f"Accuracy with {window.capitalize()} Window: {accuracy:.4f}")